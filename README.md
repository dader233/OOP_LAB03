# Лабораторная работа №2
## Класс для работы с троичными числами

### Автор
**Палкин Даниил Дмитриевич**  
Группа: **М8О-211Б-24**  
Вариант: **5**

---
<img width="709" height="81" alt="image" src="https://github.com/user-attachments/assets/f06a4858-8f7b-4510-8370-2b090a46f35c" />


---

### Сборка и тестирование

```bash
# Создание директории для сборки
mkdir build && cd build

# Конфигурация проекта
cmake ..

# Сборка
make

# Запуск тестов
./tests
```
### Вопрос 1
**Что такое правило пяти в C++? Какие из этих функций необходимо реализовать для иммутабельного класса и почему?**

**Ответ:**
Правило пяти требует явного определения пяти специальных функций для классов, управляющих ресурсами:
- Конструктор копирования
- Перемещающий конструктор  
- Копирующий оператор присваивания
- Перемещающий оператор присваивания
- Деструктор

**Для иммутабельного класса:**
- **Обязательны**: конструктор копирования, перемещающий конструктор, деструктор
- **Не нужны**: операторы присваивания (копирующий и перемещающий)

**Обоснование:**
Иммутабельные объекты не могут изменяться после создания, поэтому операторы присваивания теряют смысл - они предполагают изменение существующего объекта. Однако конструкторы необходимы для создания новых объектов на основе существующих, а деструктор - для корректного освобождения ресурсов. Перемещающий конструктор особенно важен для эффективности, так как позволяет "забирать" ресурсы у временных объектов.

---

### Вопрос 2
**Почему методы `add()` и `subtract()` объявлены как `const`, а параметры передаются как `const Three&`? Как это влияет на использование класса?**

**Ответ:**
**`const` методы:**
- Гарантируют, что текущий объект не изменится при вызове метода
- Позволяют вызывать методы на константных объектах
- Без `const` было бы невозможно: `const Three a; a.add(b);`

**`const Three&` параметры:**
- Избегают дорогостоящего копирования всего массива цифр
- Гарантируют, что исходный объект не будет изменен операцией
- Сочетают эффективность передачи по ссылке с безопасностью константности

**Влияние на использование:**
```cpp
const Three a("12");
const Three b("21");
Three result = a.add(b);  // Работает благодаря const методам
// a и b остаются неизменными, создается новый объект
```

**Без const:**
- Нарушилась бы иммутабельность класса
- Невозможно было бы работать с константными объектами
- Потерялись бы семантические гарантии

---

### Вопрос 3
**Как семантика перемещения реализована в классе `Three` и какие преимущества она дает?**

**Ответ:**
**Реализация перемещающего конструктора:**
```cpp
Three::Three(Three&& other) noexcept
    : digits(other.digits), size(other.size) {
    other.digits = nullptr;  // Источник теряет владение
    other.size = 0;
}
```

**Ключевые особенности:**
- **Безопасность**: объект-источник переводится в валидное "пустое" состояние
- **Эффективность**: вместо копирования массива передается только указатель
- **Гарантии**: `noexcept` обеспечивает безопасность при использовании в контейнерах

**Сценарии использования:**
- Возврат объектов из функций: `return std::move(result);`
- Создание из временных значений: `Three a = createThree();`
- Явное перемещение: `Three b = std::move(a);`

**Преимущества:**
- Избегаем глубокого копирования больших массивов
- Снижаем нагрузку на кучу и повышаем производительность
- Позволяем эффективно работать с временными объектами
